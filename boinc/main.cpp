#include "solverstructs.h"
#include "cxxopts.hpp"
#include "result_file.h"
#include "start_file.h"
#include "presolver.h"

#if OCL_SOLVER == 1
#include "clsolver.h"
#include <boinc/boinc_opencl.h>
#else
#include "cpusolver.h"
#endif

#include <boinc/boinc_api.h>
#include <boinc/filesys.h>
#include <cstdint>
#include <climits>
#include <vector>
#include <chrono>
#include <regex>
#include <iostream>
#include <numeric>

constexpr uint8_t MAXN = 29;
constexpr uint8_t MINN = 4;
constexpr uint8_t MIN_PRE_PLACED = 3;

// exit with failure and message
static void exit_msg(std::string msg) {
    std::cout << msg << std::endl;
    boinc_finish_message(1, msg.c_str(), false);
}

int main(int argc, char **argv) {
    boinc_init();
    bool standalone = false;
    if(boinc_is_standalone()) {
        standalone = true;
    }
    bool help = false;
    std::string presolve_file_name = "";
    std::string result_file_name = "";
    uint8_t boardsize = 0;
    uint8_t placed = 0;
    try
    {
      cxxopts::Options options("m-queens2-boinc", " - a CPU solver for the N queens problem");
      options.add_options()
        ("i,infile", "Use presolve file generated by 'presolver' as input", cxxopts::value(presolve_file_name)->default_value("infile.pre"))
        ("o,outfile", "Write result to this file", cxxopts::value(result_file_name)->default_value("outfile.res"))
        ("b,boardsize", "boarsize used for the presolver file", cxxopts::value(boardsize))
        ("p,placed", "number of qeens placed by the presolver", cxxopts::value(placed))
        ("h,help", "Print this information", cxxopts::value(help))
        ;

      auto result = options.parse(argc, argv);
      if (result.arguments().size() == 0) {
          help = true;
      }

      if (help)
      {
        std::string msg = options.help();
        exit_msg(msg);
      }

      if (result.count("boardsize") != 1) {
          std::string msg = "[boardsize] must be given exactly once";
          exit_msg(msg);
      }

      if (result.count("placed") != 1) {
          std::string msg = "[placed] must be given exactly once";
          exit_msg(msg);
      }
    } catch (const cxxopts::OptionException& e)
    {
      std::string msg = "error parsing options: ";
      msg.append(e.what());
      exit_msg(msg);
    }

    if(boardsize < MINN || boardsize > MAXN) {
        std::string msg = "[boardsize] out of range [" + std::to_string(MINN)
                        + ".." + std::to_string(MAXN) + "]: " + std::to_string(boardsize);
        exit_msg(msg);
    }

    if(placed < MIN_PRE_PLACED || placed >= boardsize) {
        std::string msg = "[placed] out of range [" + std::to_string(MIN_PRE_PLACED)
                        + ".." + std::to_string(boardsize) + "]: " + std::to_string(placed);
        exit_msg(msg);
    }

    // arguments verification done, start reading job data

    std::string resolved_infile_name = presolve_file_name;
    std::string resolved_outfile_name = result_file_name;
    if(!standalone) {
        if(boinc_resolve_filename_s(presolve_file_name.c_str(), resolved_infile_name)) {
            exit_msg("Couldn't resolve input filename: " + presolve_file_name);
        }
        if(boinc_resolve_filename_s(result_file_name.c_str(), resolved_outfile_name)) {
            exit_msg("Couldn't resolve output filename: " + result_file_name);
        }
    }

    FILE* infile = boinc_fopen(resolved_infile_name.c_str(), "rb");
    if(!infile) {
        exit_msg("Couldn't open input file: " + resolved_infile_name);
    }

    FILE* outfile = boinc_fopen(resolved_outfile_name.c_str(), "wb");
    if(!outfile) {
        exit_msg("Couldn't open output file: " + resolved_outfile_name);
    }

#if OCL_SOLVER == 1
    cl_platform_id platform;
    cl_device_id device;
    ISolver* solver = nullptr;

    if(standalone) {
        // use default
        solver = ClSolver::makeClSolver(0, 0);
    } else {
        if(boinc_get_opencl_ids(&device, &platform) != 0) {
            exit_msg("Failed to get OpenCL device");
        }

        solver = ClSolver::makeClSolver(cl::Platform(platform), cl::Device(device));
    }
#else
    ISolver* solver = new cpuSolver();
#endif
    if(!solver) {
        exit_msg("Failed to create solver");
    }

    std::vector<start_condition_t> start = start_file::load_all(infile);
    if(start.empty()) {
        exit_msg("Input file empty or corrupted");
    }

    if(fclose(infile) != 0) {
        exit_msg("Failed to close input file");
    }

    std::cout << std::to_string(start.size()) << " start conditions loaded" << std::endl;

    if(!solver->init(boardsize, placed)) {
        exit_msg("Failed to initialize solver");
    }

    std::cout << "Starting solver: boardsize: " << std::to_string(boardsize)
              << " placed: " << std::to_string(placed) << std::endl;

    // no high precision data is printed
    std::cout << std::scientific;
    std::cout.precision(2);
    // process job data
    std::vector<uint64_t> results;
    // for progress indicator
    std::vector<start_condition_t> start_single;
    start_single.resize(1);

    // track total computation time
    auto total_time_start = std::chrono::high_resolution_clock::now();

    for(size_t i = 0; i < start.size(); i++) {
        start_single[0] = start[i];
        auto time_start = std::chrono::high_resolution_clock::now();
        results.push_back(solver->solve_subboard(start_single));
        auto time_end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed = time_end - time_start;
        std::cout << "[" << std::to_string(i + 1) << "] Solved in " << elapsed.count()
                  << "s, Solutions per second: " << results[i]/elapsed.count() << std::endl;
        boinc_fraction_done(static_cast<double>(i + 1)/start.size());
    }

    auto total_time_end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> total_elapsed = total_time_end - total_time_start;

    uint64_t total_result = std::accumulate(results.begin(), results.end(), uint64_t{0});

    std::cout << "Result: " << std::to_string(total_result) << std::endl;
    std::cout << "Computation time: " << total_elapsed.count() << "s" << std::endl;
    std::cout << "Solutions per second: " << total_result/total_elapsed.count() << std::endl;

    if(!result_file::save(results, outfile)) {
        exit_msg("Failed to save result");
    }

    if(fclose(outfile) != 0) {
        exit_msg("Failed to close output file");
    }

    boinc_finish(0);
}

