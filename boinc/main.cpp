#include "cpusolver.h"
#include "solverstructs.h"
#include "cxxopts.hpp"
#include "result_file.h"
#include "start_file.h"

#include <boinc/boinc_api.h>
#include <boinc/filesys.h>
#include <cstdint>
#include <climits>
#include <vector>
#include <chrono>
#include <regex>
#include <iostream>

constexpr uint8_t MAXN = 29;
constexpr uint8_t MINN = 4;
constexpr uint8_t MIN_PRE_PLACED = 3;

// exit with failure and message
static void exit_msg(std::string msg) {
    std::cout << msg << std::endl;
    boinc_finish_message(1, msg.c_str(), false);
}

int main(int argc, char **argv) {
    boinc_init();
    bool standalone = false;
    if(boinc_is_standalone()) {
        standalone = true;
    }
    bool help = false;
    std::string presolve_file_name = "";
    std::string result_file_name = "";
    uint8_t boardsize = 0;
    uint8_t placed = 0;
    try
    {
      cxxopts::Options options("m-queens2-boinc", " - a CPU solver for the N queens problem");
      options.add_options()
        ("i,infile", "Use presolve file generated by 'presolver' as input", cxxopts::value(presolve_file_name)->default_value("infile.pre"))
        ("o,outfile", "Write result to this file", cxxopts::value(presolve_file_name)->default_value("outfile.res"))
        ("b,boardsize", "boarsize used for the presolver file", cxxopts::value(boardsize))
        ("p,placed", "number of qeens placed by the presolver", cxxopts::value(placed))
        ("h,help", "Print this information", cxxopts::value(help))
        ;

      auto result = options.parse(argc, argv);
      if (result.arguments().size() == 0) {
          help = true;
      }

      if (help)
      {
        std::string msg = options.help();
        exit_msg(msg);
      }

      if (result.count("file") != 1) {
          std::string msg = "Only one presolve file supported" ;
          exit_msg(msg);
      }

      if (result.count("boardsize") != 1) {
          std::string msg = "[boardsize] must be given exactly once";
          exit_msg(msg);
      }

      if (result.count("placed") != 1) {
          std::string msg = "[placed] must be given exactly once";
          exit_msg(msg);
      }
    } catch (const cxxopts::OptionException& e)
    {
      std::string msg = "error parsing options: ";
      msg.append(e.what());
      exit_msg(msg);
    }

    if(boardsize < MINN || boardsize > MAXN) {
        std::string msg = "[boardsize] out of range [" + std::to_string(MINN)
                        + ".." + std::to_string(MAXN) + "]: " + std::to_string(boardsize);
        exit_msg(msg);
    }

    if(placed < MIN_PRE_PLACED || placed >= boardsize) {
        std::string msg = "[placed] out of range [" + std::to_string(MIN_PRE_PLACED)
                        + ".." + std::to_string(boardsize) + "]: " + std::to_string(placed);
        exit_msg(msg);
    }

    // arguments verification done, start reading job data

    std::string resolved_infile_name = presolve_file_name;
    std::string resolved_outfile_name = result_file_name;
    if(!standalone) {
        if(!boinc_resolve_filename_s(presolve_file_name.c_str(), resolved_infile_name)) {
            exit_msg("Couldn't resolve input filename: " + presolve_file_name);
        }
        if(!boinc_resolve_filename_s(result_file_name.c_str(), resolved_outfile_name)) {
            exit_msg("Couldn't resolve output filename: " + result_file_name);
        }
    }

    FILE* infile = boinc_fopen(resolved_infile_name.c_str(), "rb");
    if(!infile) {
        exit_msg("Couldn't open input file: " + resolved_infile_name);
    }

    FILE* outfile = boinc_fopen(resolved_outfile_name.c_str(), "wb");
    if(!outfile) {
        exit_msg("Couldn't open output file: " + resolved_outfile_name);
    }

    ISolver* solver = new cpuSolver();
    if(!solver) {
        exit_msg("Failed to create solver");
    }

    std::vector<start_condition_t> start = start_file::load_all(infile);
    if(start.empty()) {
        exit_msg("Input file empty or corrupted");
    }

    if(!fclose(infile)) {
        exit_msg("Failed to close input file");
    }

    if(!solver->init(boardsize, placed)) {
        exit_msg("Failed to initialize solver");
    }

    // process job data
    uint64_t result = 0;
    for(size_t i = 0; i < start.size(); i++) {
        auto time_start = std::chrono::high_resolution_clock::now();
        result += solver->solve_subboard(start);
        auto time_end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed = time_end - time_start;
        std::cout << "[" << std::to_string(i + 1) << "] Solved in " << std::to_string(elapsed.count()) << "s" << std::endl;
        boinc_fraction_done(static_cast<double>(i + 1)/start.size());
    }

    if(!result_file::save(result, outfile)) {
        exit_msg("Failed to save result");
    }

    if(!fclose(outfile)) {
        exit_msg("Failed to close output file");
    }

    boinc_finish(0);
}

